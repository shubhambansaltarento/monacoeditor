[
  {
    "label": "main",
    "kind": "Snippet",
    "insertText": "#include <iostream>\n\nint main() {\n\t${1:// code}\n\treturn 0;\n}",
    "documentation": "Main function template",
    "category": "main"
  },
  {
    "label": "main with args",
    "kind": "Snippet",
    "insertText": "#include <iostream>\n\nint main(int argc, char* argv[]) {\n\t${1:// code}\n\treturn 0;\n}",
    "documentation": "Main function with command line arguments",
    "category": "main"
  },
  {
    "label": "include",
    "kind": "Snippet",
    "insertText": "#include <${1:iostream}>",
    "documentation": "Include standard library header",
    "category": "preprocessor"
  },
  {
    "label": "include custom",
    "kind": "Snippet",
    "insertText": "#include \"${1:header.h}\"",
    "documentation": "Include custom header file",
    "category": "preprocessor"
  },
  {
    "label": "using namespace",
    "kind": "Snippet",
    "insertText": "using namespace ${1:std};",
    "documentation": "Using namespace directive",
    "category": "namespaces"
  },
  {
    "label": "namespace",
    "kind": "Snippet",
    "insertText": "namespace ${1:name} {\n\t${2:// namespace content}\n}",
    "documentation": "Namespace definition",
    "category": "namespaces"
  },
  {
    "label": "cout",
    "kind": "Function",
    "insertText": "std::cout << ${1:\"message\"} << std::endl;",
    "documentation": "Output to console",
    "category": "io"
  },
  {
    "label": "cin",
    "kind": "Function",
    "insertText": "std::cin >> ${1:variable};",
    "documentation": "Input from console",
    "category": "io"
  },
  {
    "label": "for loop",
    "kind": "Snippet",
    "insertText": "for (int ${1:i} = 0; ${1:i} < ${2:n}; ${1:i}++) {\n\t${3:// loop body}\n}",
    "documentation": "Traditional for loop",
    "category": "control"
  },
  {
    "label": "range-based for",
    "kind": "Snippet",
    "insertText": "for (const auto& ${1:item} : ${2:container}) {\n\t${3:// loop body}\n}",
    "documentation": "Range-based for loop (C++11)",
    "category": "control"
  },
  {
    "label": "while loop",
    "kind": "Snippet",
    "insertText": "while (${1:condition}) {\n\t${2:// loop body}\n}",
    "documentation": "While loop",
    "category": "control"
  },
  {
    "label": "do-while loop",
    "kind": "Snippet",
    "insertText": "do {\n\t${1:// loop body}\n} while (${2:condition});",
    "documentation": "Do-while loop",
    "category": "control"
  },
  {
    "label": "if statement",
    "kind": "Snippet",
    "insertText": "if (${1:condition}) {\n\t${2:// code}\n}",
    "documentation": "If statement",
    "category": "control"
  },
  {
    "label": "if-else statement",
    "kind": "Snippet",
    "insertText": "if (${1:condition}) {\n\t${2:// if code}\n} else {\n\t${3:// else code}\n}",
    "documentation": "If-else statement",
    "category": "control"
  },
  {
    "label": "switch statement",
    "kind": "Snippet",
    "insertText": "switch (${1:variable}) {\n\tcase ${2:value1}:\n\t\t${3:// code}\n\t\tbreak;\n\tcase ${4:value2}:\n\t\t${5:// code}\n\t\tbreak;\n\tdefault:\n\t\t${6:// default code}\n\t\tbreak;\n}",
    "documentation": "Switch statement",
    "category": "control"
  },
  {
    "label": "function",
    "kind": "Snippet",
    "insertText": "${1:int} ${2:function_name}(${3:parameters}) {\n\t${4:// function body}\n\treturn ${5:value};\n}",
    "documentation": "Function definition",
    "category": "functions"
  },
  {
    "label": "void function",
    "kind": "Snippet",
    "insertText": "void ${1:function_name}(${2:parameters}) {\n\t${3:// function body}\n}",
    "documentation": "Void function definition",
    "category": "functions"
  },
  {
    "label": "lambda",
    "kind": "Snippet",
    "insertText": "auto ${1:lambda} = [${2:capture}](${3:parameters}) -> ${4:return_type} {\n\t${5:// lambda body}\n\treturn ${6:value};\n};",
    "documentation": "Lambda function (C++11)",
    "category": "functions"
  },
  {
    "label": "simple lambda",
    "kind": "Snippet",
    "insertText": "[${1:capture}](${2:parameters}) { ${3:// body} }",
    "documentation": "Simple lambda expression",
    "category": "functions"
  },
  {
    "label": "class",
    "kind": "Snippet",
    "insertText": "class ${1:ClassName} {\npublic:\n\t${2:// public members}\n\nprivate:\n\t${3:// private members}\n};",
    "documentation": "Class definition",
    "category": "classes"
  },
  {
    "label": "struct",
    "kind": "Snippet",
    "insertText": "struct ${1:StructName} {\n\t${2:// struct members}\n};",
    "documentation": "Structure definition",
    "category": "classes"
  },
  {
    "label": "constructor",
    "kind": "Snippet",
    "insertText": "${1:ClassName}(${2:parameters}) : ${3:member_initializer_list} {\n\t${4:// constructor body}\n}",
    "documentation": "Constructor with initializer list",
    "category": "classes"
  },
  {
    "label": "destructor",
    "kind": "Snippet",
    "insertText": "~${1:ClassName}() {\n\t${2:// destructor body}\n}",
    "documentation": "Destructor definition",
    "category": "classes"
  },
  {
    "label": "copy constructor",
    "kind": "Snippet",
    "insertText": "${1:ClassName}(const ${1:ClassName}& other) {\n\t${2:// copy constructor body}\n}",
    "documentation": "Copy constructor",
    "category": "classes"
  },
  {
    "label": "move constructor",
    "kind": "Snippet",
    "insertText": "${1:ClassName}(${1:ClassName}&& other) noexcept {\n\t${2:// move constructor body}\n}",
    "documentation": "Move constructor (C++11)",
    "category": "classes"
  },
  {
    "label": "operator=",
    "kind": "Snippet",
    "insertText": "${1:ClassName}& operator=(const ${1:ClassName}& other) {\n\tif (this != &other) {\n\t\t${2:// assignment logic}\n\t}\n\treturn *this;\n}",
    "documentation": "Copy assignment operator",
    "category": "operators"
  },
  {
    "label": "operator<< overload",
    "kind": "Snippet",
    "insertText": "std::ostream& operator<<(std::ostream& os, const ${1:ClassName}& obj) {\n\tos << ${2:obj.member};\n\treturn os;\n}",
    "documentation": "Stream insertion operator overload",
    "category": "operators"
  },
  {
    "label": "template class",
    "kind": "Snippet",
    "insertText": "template<typename ${1:T}>\nclass ${2:ClassName} {\npublic:\n\t${3:// template class body}\n};",
    "documentation": "Template class definition",
    "category": "templates"
  },
  {
    "label": "template function",
    "kind": "Snippet",
    "insertText": "template<typename ${1:T}>\n${2:T} ${3:function_name}(${4:T parameter}) {\n\t${5:// template function body}\n\treturn ${6:parameter};\n}",
    "documentation": "Template function definition",
    "category": "templates"
  },
  {
    "label": "vector",
    "kind": "Snippet",
    "insertText": "std::vector<${1:int}> ${2:vec};",
    "documentation": "Vector declaration",
    "category": "containers"
  },
  {
    "label": "vector with size",
    "kind": "Snippet",
    "insertText": "std::vector<${1:int}> ${2:vec}(${3:size});",
    "documentation": "Vector with initial size",
    "category": "containers"
  },
  {
    "label": "vector with values",
    "kind": "Snippet",
    "insertText": "std::vector<${1:int}> ${2:vec} = {${3:1, 2, 3}};",
    "documentation": "Vector with initial values",
    "category": "containers"
  },
  {
    "label": "array",
    "kind": "Snippet",
    "insertText": "std::array<${1:int}, ${2:size}> ${3:arr};",
    "documentation": "STL array declaration",
    "category": "containers"
  },
  {
    "label": "map",
    "kind": "Snippet",
    "insertText": "std::map<${1:Key}, ${2:Value}> ${3:map};",
    "documentation": "Map declaration",
    "category": "containers"
  },
  {
    "label": "unordered_map",
    "kind": "Snippet",
    "insertText": "std::unordered_map<${1:Key}, ${2:Value}> ${3:map};",
    "documentation": "Unordered map declaration",
    "category": "containers"
  },
  {
    "label": "set",
    "kind": "Snippet",
    "insertText": "std::set<${1:int}> ${2:set};",
    "documentation": "Set declaration",
    "category": "containers"
  },
  {
    "label": "unique_ptr",
    "kind": "Snippet",
    "insertText": "std::unique_ptr<${1:Type}> ${2:ptr} = std::make_unique<${1:Type}>(${3:args});",
    "documentation": "Unique pointer with make_unique",
    "category": "smart_pointers"
  },
  {
    "label": "shared_ptr",
    "kind": "Snippet",
    "insertText": "std::shared_ptr<${1:Type}> ${2:ptr} = std::make_shared<${1:Type}>(${3:args});",
    "documentation": "Shared pointer with make_shared",
    "category": "smart_pointers"
  },
  {
    "label": "try-catch",
    "kind": "Snippet",
    "insertText": "try {\n\t${1:// code that may throw}\n} catch (const ${2:std::exception}& e) {\n\t${3:// exception handling}\n}",
    "documentation": "Try-catch block",
    "category": "exceptions"
  },
  {
    "label": "throw",
    "kind": "Snippet",
    "insertText": "throw ${1:std::runtime_error}(\"${2:error message}\");",
    "documentation": "Throw exception",
    "category": "exceptions"
  },
  {
    "label": "enum class",
    "kind": "Snippet",
    "insertText": "enum class ${1:EnumName} {\n\t${2:VALUE1,\n\tVALUE2}\n};",
    "documentation": "Scoped enumeration (C++11)",
    "category": "types"
  },
  {
    "label": "auto",
    "kind": "Snippet",
    "insertText": "auto ${1:variable} = ${2:value};",
    "documentation": "Auto type deduction",
    "category": "variables"
  },
  {
    "label": "const auto",
    "kind": "Snippet",
    "insertText": "const auto ${1:variable} = ${2:value};",
    "documentation": "Const auto variable",
    "category": "variables"
  },
  {
    "label": "static_cast",
    "kind": "Function",
    "insertText": "static_cast<${1:TargetType}>(${2:value})",
    "documentation": "Static cast",
    "category": "casting"
  },
  {
    "label": "dynamic_cast",
    "kind": "Function",
    "insertText": "dynamic_cast<${1:TargetType}>(${2:value})",
    "documentation": "Dynamic cast",
    "category": "casting"
  },
  {
    "label": "const_cast",
    "kind": "Function",
    "insertText": "const_cast<${1:TargetType}>(${2:value})",
    "documentation": "Const cast",
    "category": "casting"
  },
  {
    "label": "reinterpret_cast",
    "kind": "Function",
    "insertText": "reinterpret_cast<${1:TargetType}>(${2:value})",
    "documentation": "Reinterpret cast",
    "category": "casting"
  },
  {
    "label": "std::find",
    "kind": "Function",
    "insertText": "std::find(${1:container}.begin(), ${1:container}.end(), ${2:value})",
    "documentation": "Find element in container",
    "category": "algorithms"
  },
  {
    "label": "std::sort",
    "kind": "Function",
    "insertText": "std::sort(${1:container}.begin(), ${1:container}.end());",
    "documentation": "Sort container",
    "category": "algorithms"
  },
  {
    "label": "std::for_each",
    "kind": "Function",
    "insertText": "std::for_each(${1:container}.begin(), ${1:container}.end(), [](${2:auto& item}) {\n\t${3:// process item}\n});",
    "documentation": "For each algorithm with lambda",
    "category": "algorithms"
  },
  {
    "label": "pragma once",
    "kind": "Snippet",
    "insertText": "#pragma once",
    "documentation": "Include guard",
    "category": "preprocessor"
  },
  {
    "label": "header guard",
    "kind": "Snippet",
    "insertText": "#ifndef ${1:HEADER_NAME_H}\n#define ${1:HEADER_NAME_H}\n\n${2:// header content}\n\n#endif // ${1:HEADER_NAME_H}",
    "documentation": "Traditional header guard",
    "category": "preprocessor"
  },
  {
    "label": "constexpr",
    "kind": "Snippet",
    "insertText": "constexpr ${1:auto} ${2:variable} = ${3:value};",
    "documentation": "Constexpr variable",
    "category": "variables"
  },
  {
    "label": "constexpr function",
    "kind": "Snippet",
    "insertText": "constexpr ${1:auto} ${2:function_name}(${3:parameters}) {\n\treturn ${4:expression};\n}",
    "documentation": "Constexpr function",
    "category": "functions"
  }
]